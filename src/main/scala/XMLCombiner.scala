import java.lang

import Utils.MyConfig
import org.apache.hadoop.io.Text
import org.apache.hadoop.mapreduce.Reducer
import org.slf4j.LoggerFactory

import scala.collection.mutable.ListBuffer

class XMLCombiner extends Reducer[Text,Text,Text,Text] {

//  Fetching the required key prefixes which by it to kind the type of key and according assign the
//  merge operation
  val venueAuthorCountPrefix:String = MyConfig.getString("keyPrefixes.venueAuthorCount")
  val authorCoauthorPrefix:String = MyConfig.getString("keyPrefixes.authorCoauthor")
  val authorPublishedYearPrefix:String = MyConfig.getString("keyPrefixes.authorPublishedYear")
  val venuePublicationAuthorCountsPrefix:String = MyConfig.getString("keyPrefixes.venuePublicationAuthorCounts")
  val authorAndItsCoAuthorCountPrefix:String = MyConfig.getString("keyPrefixes.authorAndItsCoAuthorCount")
  val continuousYear:Int = MyConfig.getInt("statisticsParameters.numberOfContinuousYears")

  val logger = LoggerFactory.getLogger(this.getClass)

  /**
   *
   * @param key  all the keys that are generated by mapper after a record spilt
   * @param values collection of all the value belonging to the provided key
   * @param context object which will pass the key and value generated from this operation to the reducer
   *                for final reduce operation
   */
  override def reduce(key: Text, values: lang.Iterable[Text], context: Reducer[Text, Text, Text, Text]#Context): Unit = {

//    fetch the key prefix to decide what kind of combination has to be done for this
//    key.
    val keyType:String = key.toString.split("#")(0)
    logger.info("reduce function is called for key: "+ keyType)

//    calling the required function depending on the kind of key
    keyType match{
      case `venueAuthorCountPrefix` =>{
        logger.info("venueAuthorCountMerge is calling....")
        venueAuthorCountMerge(key, values, context)
      }

      case `authorCoauthorPrefix` =>
        {
          logger.info("authorCoauthorMerge is calling....")
          authorCoAuthorMerge(key, values, context)
        }

      case `authorPublishedYearPrefix` =>
        {
          logger.info("authorYearMerge is calling ....")
          authorYearMerge(key,values,context)
        }

      case `venuePublicationAuthorCountsPrefix`=>
        {
          logger.info("venueAuthorCountTitleMerge is calling....")
          venueAuthorCountTitleMerge(key,values,context)
        }

      case _ =>

    }
  }

  /**
   *
   * @param key  gets the key of the form AuthorAndItsCoAuthors#Author:<AuthorName>
   * @param values get the value of the form AuthorName
   * @param context
   *
   * produces key of the form AuthorAndItsCoAuthors
   * produces value of the form Count:<CoAuthor Count>#Author:<AuthorName>
   */
  def authorCoAuthorMerge(key: Text, values: lang.Iterable[Text], context: Reducer[Text, Text, Text, Text]#Context) = {
    logger.info("authorCoAuthorMerge is called for key : "+key.toString)

//    fetching Author Details from key.
    val authorDetails: String = key.toString.split("#")(1)
    var coauthor: Set[String] = Set()

//    fetching the Unique coAuthor Names from Values
    values.forEach(((i: Text) => coauthor += i.toString))
    context.write(new Text(authorAndItsCoAuthorCountPrefix), new Text("Count:"+coauthor.size.toString+"#"+authorDetails))
  }

  /**
   *
   * @param key of the form VenueAuthorCount#Venue:<VenueName>#Author:<AuthorName>
   * @param values always one
   * @param context
   *
   * generates the key of the form VenueAuthorCount#Venue:<VenueName>
   * generates the value of the form Count:<Number of Publication>#Author:<AuthorName>
   */

  def venueAuthorCountMerge(key: Text, values: lang.Iterable[Text], context: Reducer[Text, Text, Text, Text]#Context) = {

    logger.info("venueAuthorCountMerge is called for key: "+key.toString)
    val venueDetail:String = key.toString.split("#")(1)
    val authorDetail = key.toString.split("#")(2)
    var count: Int = 0
    values.forEach((value) => count += 1)
    context.write(new Text(venueAuthorCountPrefix +"#"+venueDetail), new Text("Count:"+count.toString+"#"+authorDetail))
  }

  /**
   *
   * @param key of the form AuthorAndPublishYear#Author:<AuthorName>
   * @param values is the years in which Author has published any of his/her work
   * @param context
   *
   * generates the key of the form AuthorPublishedYear
   * generates the value of the form Author:<AuthorName>#YearEncoding:<1111_11>
   */
  def authorYearMerge(key: Text, values: lang.Iterable[Text], context: Reducer[Text, Text, Text, Text]#Context) = {

    logger.info("authorYearMerge is Called for key: "+key.toString)
    var years: Set[Int] = Set[Int]()
    val authorDetails = key.toString.split("#")(1)

    values.forEach(((value) => years += value.toString.toInt))

//    Produces the ouput key value only if author has published minimum number of work specified on config
    if (years.size >= continuousYear) {
      val yearEncoding:String = getYearEncoding(years)
      context.write(new Text(authorPublishedYearPrefix), new Text(authorDetails+"#YearEncode:"+yearEncoding))
    }
  }

  /**
   *
   * @param key gets key of the form VenuePublicationAuthorCounts#Venue:<VenueName>#AuthorCount:<NumberOfAuthors>
   * @param values gets values of the form <Name of Titles>
   * @param context
   *    generate key of form VenuePublicationAuthorCounts#Venue:<VenueName>
   *    generate value of form AuthorCount:<NumberOfAuthors>#Titles:<titles separated by comma>
   */
  def venueAuthorCountTitleMerge(key: Text, values: lang.Iterable[Text], context: Reducer[Text, Text, Text, Text]#Context) = {
    logger.info("venueAuthorCountTitle is called...")
    var titles:ListBuffer[String] = ListBuffer[String]()
    val venueDetails = key.toString.split("#")(1)
    val authorCountDetails = key.toString.split("#")(2)
    values.forEach(value => titles += value.toString)
    logger.info(titles.mkString(","))
    context.write(new Text(venuePublicationAuthorCountsPrefix+"#"+venueDetails),new Text(authorCountDetails +"#Titles:"+titles.mkString(",")))
  }

  def getYearEncoding(years:Set[Int]): String =
  {
    val sortedYear:List[Int] = years.toList.sorted
    var builder = new StringBuilder
    var previous:Int = sortedYear(0)
    1 until sortedYear.length foreach {
      i =>
        if (previous + 1 == sortedYear(i))
          builder = builder.append("1")
        else
          builder = builder.append("_")
        previous = sortedYear(i)
    }
    builder.toString()
  }
}